---
title: "Making (Nice!) Plots in R"
subtitle: "An R exercise within the Umbrella Academy course"
description: "This is an exercise to help 'wet lab' scientists feel comfortable manipulating data and creating common charts in R"

author:
  - name: Kelsey Monson
    degrees:
      - PhD
      - MS
    orcid: 0000-0003-1093-8628
    email: kelsey.monson@mssm.edu
    affiliations:
      - ref: ISMMS

affiliations:
  - id: ISMMS
    name: Icahn School of Medicine at Mount Sinai
    city: New York
    state: NY
    department: Immunology and Immunotherapy

title-block-banner: "#f0f3f5"
title-block-banner-color: "black"

keywords: "R, Data Analysis, Data Viz"
date: today

format: 
  html: 
    toc: true
    number-sections: true
    css: style.css
    code-overflow: wrap
    
fig-cap-location: margin
editor: visual
---

## Introduction

The goal of **The Umbrella Academy** is to familiarize "wet lab" scientists with useful "dry lab" tools. Therefore, this exercise is geared primarily towards basic data manipulation to generate aesthetically pleasing plots in R.

R is an excellent tool for generating beautiful data visualizations, and is much more flexible and customizable than other tools like Excel or GraphPad.

Another major benefit of R is that it is free to use and open source, unlike other proprietary statistical computing software like SAS or STATA.

But first, before we dive into the exercise itself, let's familiarize ourselves with some basics of working with R in RStudio.

### R and RStudio

By now, you should have installed what's often called **"Base-R."**

**What is R?**

According to its creators,

> R is "a language and environment for statistical computing and graphics" and "an integrated suite of software facilities for data manipulation, calculation and graphical display."

(You can read more about it [here](https://www.r-project.org/about.html).)

But what does that mean in practice?

You might have run R after you installed it, and seen something like this, magically transporting yourself to circa 2004:

![**Base R GUI.** This always reminds me of an AIM chat window (if anyone is old enough to remember that).](assets/RGui.png)

This is "Base-R," and it's not especially user-friendly (where are you even supposed to start? how do you run a command?). While it's perfectly functional, it's not the ideal way to interact with R.

Enter: **RStudio**.

I'm writing this exercise in RStudio right now, see? ![RStudio screenshot](assets/RStudio.png)

To be honest, I've been coding in R since 2017 and have never once written a script or performed an analysis in Base-R.

Maybe you can see why -- RStudio is what's called an **"integrative development environment" (IDE).**

This goes beyond even a "graphical user interface" (GUI), in that it provides tools to write, execute, and debug R code, manage the objects and variables you create, keep track of your files and projects, render plots, read help documentation... the list goes on.

We'll explore RStudio in depth throughout the exercise, but first we need to learn a bit more about how R works.

### Data Types and Variables

Every basic programming class with include this section (in fact, if you completed your [homework](https://vscodeedu.com/courses/intro-to-python) this should look quite familiar, though R and Python are slightly different in this regard).

I'll try to make this brief:

#### Variable Structures in R

-   **Data Frame:** A table-like structure with rows and columns. Each column can store a different data type, making it ideal for organizing datasets.
-   **Tibble:** A modern version of a data frame, offering improved printing behavior and no row names by default.
-   **Vector:** A one-dimensional collection that holds elements of the same data type.
-   **List:** An ordered collection that can store elements of different types, allowing greater flexibility.
-   **Matrix:** A two-dimensional version of a vector with rows and columns, where all elements share the same type.
-   **Array:** A multi-dimensional collection, similar to a matrix but capable of handling more than two dimensions.

You will likely most often be working with **Data Frames** or **Tibbles** to create figures, but will probably use all of the variable types at one point or another.

#### Data Types in R

-   **Numeric:** The default type used for numbers, including decimals.
-   **Factor:** A special structure for categorical data that defines a limited set of values.
-   **Integer:** Whole numbers explicitly defined with an "L" suffix (e.g., 10L).
-   **Logical:** Represents Boolean values: TRUE or FALSE.
-   **Character:** Text strings used to represent words or sentences.
-   **Complex:** Numbers that include both a real and an imaginary component (e.g., 2+3i).
-   **Raw:** Used for storing raw byte data.

Some of these you won't interact with much (I've never worked with Complex or Raw data, I don't think...), others are pretty essential. **Factors** are especially important, and we will discuss them more later.

These definitions are drawn from [this R Workshop GitHub](https://github.com/MVesuviusC/R_workshop/tree/main), which inspired a few other sections of this class (thank you, [MVesuviusC](https://github.com/MVesuviusC)!).

#### The `str()` function

There is an extremely useful function in R to tell you the structure of an object: `str()`

Here I'm going to show the difference between a **Numeric** variable and an **Integer**, by creating two **Vectors**:

```{r}
# Create the vectors
num <- c(1,2,3)
int <- c(1L,2L,3L)

# Look at their structure with `str()`
str(num)
str(int)
```

Breaking down the above code, we

1.  Created the variables using `<-`, otherwise known as the `assignment operator`
2.  Combined the numbers/integers and passed them to our new variables using the combine function `c()`
3.  Checked their structure by passing the object (either `num` or `int`) to the `str()` function.

If you want, you can *coerce* a data type into another one.

```{r}
# Let's say I actually wanted `num` to be an integer:
num <- as.integer(num)
str(num)

# Or even a character:
num <- as.character(num)
str(num)
```

But, oops, actually, just kidding, I really wanted `num` to be numeric. We can change it back:

```{r}
num <- as.numeric(num)
str(num)
```

::: callout-warning
**Be careful not to coerce a variable into an impossible data type!**
:::

Note what happens if we try to coerce a character vector into a numeric vector, even if we know that the character *could* represent a number:

```{r}
number <- c("one","two","three")
str(number)

number <- as.numeric(number)
str(number)
```

R isn't reading and evaluating our characters to assume what they might mean, so it isn't going to automatically convert `one` into `1`.

If you have numeric variables in your dataset, it's best to save them initially as numbers in your raw data, and treat them as either numeric or integer variables in R.

#### Why use **Factors**?

::: callout-caution
**The default behavior in R is to treat text variables alphabetically** unless we specify otherwise.

Here's an example where that might become confusing.

Say we had a dataset from a contest, where participants could come in first, second, third, or fourth.

```{r}
rankings <- c("first","second","third","fourth")
# If we look at the structure of our variable, we see them in the order we would expect...
str(rankings)

# But if we use the table() function to summarize the data, we see it lists them alphabetically
table(rankings)

```

How do we fix this if we want them to be ordered logically, from first to fourth?
:::

This is where the **Factor** variable type comes in. We can specify that this categorical variable is a factor, and tell it the levels we expect:

```{r}
rankings <- as.factor(rankings)
# If we just coerce the variable into a factor, we still have the same problem, because R doesn't know that we want them in order:
str(rankings)
table(rankings)

# Instead, we can explicitly tell it the order we want with the "levels" argument:
rankings <- factor(rankings, levels=c("first","second","third","fourth"))
table(rankings)

# We can set the levels to be whatever we want -- for example, we could list them backwards:
rankings <- factor(rankings, levels=c("fourth","third","second","first"))
table(rankings)
```

::: {.callout-tip collapse="true"}
##### Extra Credit

Why did the `str()` function print the rankings in the correct order the very first time, even though using the `table()` function showed that R was treating them alphabetically?

Because when we created the `rankings` variable, we entered the variable names in the logical order. If we had created the variable with them out of order, they would have printed out of order, but R would still treat them alphabetically:

```{r}
rankings <- c("third","second","fourth","first")
# Prints the character variable in the silly order we supplied...
str(rankings)
# But still treats it alphabetically
table(rankings)

```
:::

Changing the levels of your **Factor** variables can be very useful when it comes to plotting data, as we will see.

### Getting Help

R has a very robust help system, and it's as easy as prepending a `?` to the name of a function.

There are actually two ways to search for help:

-   Single question mark: `?`

    -   Displays the help documentation for a specific function.
    -   e.g. `?mean()` will show you the help documents for the Base-R function `mean` (for calculating means).
    -   This type of search is best if you are looking for information on a specific function that you know the name of (for example, if you are trying to recreate a figure using code you found online and want to know what a specific function does).

-   Double question mark: `??`

    -   Searches the help documentation for the keyword you provide.
    -   e.g. `??mean()` will look for all the functions (and their documentation) that include the word `mean` and will return a list that you can select from.
    -   Because this searches documentation for your keyword(s) and not just function names, this is a good option if you know *what* you want a function to do, even if you don't know its name, and/or you want to see if there are multiple functions to choose from.
    -   This type search of works better if you use more specific keywords, since many functions share common words.

One of the most useful reasons to use `?` is because, in addition to giving you general information about how a function works, it tells you the possible arguments (what can go inside the parentheses) as well as any default behavior.

I use `?` almost every time I'm coding in R -- sometimes just to see what other cool things a function I'm using can do!

### Packages

Did you notice how I specified above that `mean()` is a function in Base-R? R comes ready-made with a number of essential statistical and graphical functions built into it.

But one of the best things about R is that there is a huge community of other R users who create **packages**, basically collections of related functions to do specific things in R.

This is how people can use R to calculate differential gene expression from RNA-seq data, plot complex microbiome phylogenetic trees, use machine learning tools to make sophisticated predictive statistical models, and more.

These tasks are all very different and require diverse skills and expertise to program and execute. But with the broad and brilliant user base of R, there are people who make packages to do each of these things (and so much more!).

So how do we get these packages?

-   Almost all packages can be installed with the intuitively named `install.packages("package_name")` function.
-   Some bioinformatics-specific tools need to be installed from [Bioconductor](https://www.bioconductor.org/) using `BiocManager::install("package_name")`.
-   Some packages can be installed directly from GitHub using `devtools::install_github("package_name")`.
-   To load and use a downloaded package, use `library(package_name)`.

::: callout-note
#### A few notes on packages

-   When installing a package, the package name must be enclosed in quotes.
-   When loading a package, you do not need to use quotes around the name.
-   You don't need to *download* a package more than once (though you may need to update it).
-   However, you must *load* a package every time before you can use it.
:::

### Navigating RStudio

Now that you understand the basics, it's time to dive in!

#### Working directories

Remember in our [last lesson](../Command-Line/Command_Line_Exercise.md) when we learned the command `pwd` to see what directory we were in on the HPC?

There is a similar command in R:

```{r}
getwd()
```

You can see I'm currently in my project directory on the Zamarin Lab computer.

The syntax for commands in R is typically the `function` followed by the arguments to the function in parentheses `(arguments)`.

With `getwd()`, we're asking the question of what directory we're in, so we aren't giving it any arguments. But if we want to *change* the directory, we can use the below command, giving it the path of the directory we want to move to:

```{r}
setwd("C:/Users/Zamarin Lab/Documents/GitHub/Umbrella-Academy/R-Project")
```

::: callout-note
`getwd()` is short for "**get** working directory" (whereas `pwd` was "**print** working directory").

`setwd()` is short for "**set** working directory."

You can remember these since "set" and "get" rhyme!
:::

#### R Projects

Some people believe very strongly that you should never include `setwd()` in your R scripts. In fact, they even threaten to [come to your office and set your computer on fireðŸ”¥](https://www.tidyverse.org/blog/2017/12/workflow-vs-script/).

Rather, they argue that it is much better to create a folder for the specific project you are working on, and then create an R Project (or similar, but for our purposes we will discuss R Projects).

::: {.callout-tip collapse="true"}
##### What is an R Project?

-   A type of file that functions with RStudio
-   They have the `.Rproj` file extension
-   R projects are each associated with a directory
-   They are useful when working with many files for one purpose, hence the name â€œprojectâ€
-   They â€œknowâ€ which files are relevant to a project: when you open the project, RStudio will load those files automatically
-   If we are working in an R project, our working directory is automatically set as the folder that the project is associated with -- so no need to use `setwd()` (and have our computers set on fireðŸ”¥)
-   This is especially useful if you need to move your project directory or change computers -- you don't have to rewrite the path to your working directory if the project moves, which is really beneficial for collaboration and reproducibility

Adapted from [*Communicate Data with R*](https://communicate-data-with-r.netlify.app/) -- full post and more info [here](https://communicate-data-with-r.netlify.app/docs/baser/workingprojects/).
:::

For this exercise, we will create an R Project, just to teach best practices.

#### RStudio Windows

If you launch RStudio now, you will see three panes (or windows).

::: {.callout-caution collapse="true"}
##### Before we progress...

...we need to turn off a few RStudio defaults that will make our lives better.

Basically, in an ideal world, you should be able to run all your code from start to finish and get the same result.

However, RStudio's default behavior is to *restore your previous workspace*. This can cause problems since your previous workspace might include objects or data from a different project or version of your code, making it difficult to reproduce your results consistently. More on this [here](https://www.sesync.org/resources/tips-smooth-rstudio-workflow-and-reproducible-r-code).

**To turn off workspace saving and loading:**

-   Tools -\> Global Options -\> General -\> Uncheck â€œRestore .RData into workspace at startupâ€
-   Tools -\> Global Options -\> General -\> Change â€œSave workspace to .RData on exitâ€ to â€œNeverâ€ ![](assets/Global_Options.png)
:::

Now that we've turned off those defaults, let's create a new script so you can see all four of the typical windows you will be working with when coding in RStudio:

![Create a new script by going to File -\> New File -\> R Script](assets/New_File.png)

Now you should see something like this:

![**The four RStudio windows.** Yours may be in a different orientation than in this figure. These images and annotations are from the silly yet useful book [*YaRrr! The Pirateâ€™s Guide to R*](https://bookdown.org/ndphillips/YaRrr/)](https://bookdown.org/ndphillips/YaRrr/images/RStudio_Screenshot_Labels.png)

-   The **Console** is the same as if you had just launched Base-R -- you can enter and run commands here, but they will not be stored for future use.
-   The **Source** section (with your new script) can also be generated in Base-R
    -   However, there's no "Run" button in Base-R to run your code.
    -   That said, it's much faster and easier to use a keyboard shortcut to execute your codes -- just type `CTRL + Enter`.
    -   Try that now by typing `getwd()`, followed by `CTRL + Enter`.
    -   This will work in either the **Console** or the **Source**.
    -   If you ran it in the **Console**, you'll note that the command disappeared. Try using the `Up` arrow to retrieve the command and run it again!
-   We haven't created any variables (yet) to go into the **Environment**, but check out the **History** tab -- you should see the `getwd()` command(s) you just ran!
-   The last window with **Files, Plots, Packages, etc.** will also look fairly empty, but not for long!

#### RStudio Projects

As promised, we will create an R Project for this exercise.

Go ahead and close your new script containing the brilliant and groundbreaking code you just wrote (`getwd()`), no need to save it.

Now, create a new project and new directory:

![Create a new project by going to File -\> New Project. Then create a New Directory, and finally New Project.](assets/New_Proj.png)

You can name your new directory whatever you'd like, as long as you remember it's for this project.

Now we'll go back and create a new R script in our project folder.

::: {.callout-note collapse="true"}
##### A note on document types

For this exercise, we will be using an R script to write and execute our code.

There are other document types, like R Markdown, or the newer Quarto (this is actually a Quarto document). These file types are a bit more advanced and require you to know Markdown syntax, but can be very helpful for actual projects. They allow you to combine code, text, and output very seamlessly, which is good for reproducibility.

If you want to learn more, I highly recommend this course, [*Productive R Workflow*](https://www.productive-r-workflow.com/). Contact me if you are interested; the creator offers group rates for teams.
:::

Okay, so we now have our R Project and our fresh new script. It's time to begin!

## Exercise
```{r}
#| echo: false
#| warning: false

library(tidyverse)
library(viridis)
library(readxl)
library(gtExtras)

```

As I mentioned at the beginning of this document, our goal today is to learn some helpful R codes to generate beautiful plots. 

Since you all have different projects and datasets (some of which may not even exist yet!), we will use some example data for the exercise.

Some packages (and Base-R) include their own test data. This is useful when you want to see what a package is capable of, and is especially good for testing specific functions. If the package documentation shows you how to run functions using test data that you can download too, you can both recreate the example they are showing you and more easily apply it to your own data. 

We will use the `starwars` test dataset from the `tidyverse` package as our example data today. 

### Getting Started
I've created an [R Script](Getting_Started_with_R_script.R) that includes the code necessary to generate the plots for this exercise. Go ahead and open that script now. 

You can use this script as a template/cheat sheet to work off of as you build your own script today, but the best way to learn to code is to type out the commands yourself to start building your muscle memory ðŸ’ª

So you can copy/paste long package, variable, and file names, but it's a good idea to type out functions and commands so you understand and begin to rememebr the syntax. 

#### Install and Load Packages, Download Data

Please download and load the packages that we will use today (listed at the top of the script). 

While we will use the `starwars` dataset built into the `tidyverse`, you will eventually need to know how to load in your own data to R, so I saved a small version of the dataset to teach you to do just that.

Download the [dataset](input/small_star_wars.xlsx) from the GitHub:

![Navigate to the *input* folder, select the file, and select "Copy raw file."](assets/Download_Data.png)
Then create a folder in your own project directory called `input` and save the file there.

Reading in the data should now look like:
```{r}
small_star_wars <- read_excel("input/small_star_wars.xlsx", na="NA")
```

If you followed the directions to create your R Project, you should be able to execute the code exactly as written (this is the power of not needing to include `setwd()` in  your code!).

#### Explore the Data

This dataset is more complicated than the vectors I created earlier. What does it look like if we run `str()` on this?
```{r}
str(small_star_wars)
```

We can see that `str()` gives us more information than just the data type of each variable -- we can now see that this is a **Tibble** (a fancy version of a **Data Frame**). 

**Tibbles** and **Data Frames** can contain variables of different types -- you can see that this contains both numeric and character variables.

To get a general idea of what your Tibble looks like, you can use the `summary()` function:
```{r}
summary(small_star_wars)
```

There is a package called `gtExtras` that creates very nice looking summary tables with very simple code:
```{r}

small_star_wars %>% 
  gt()

```

This code uses ` %>% `, which is called the `pipe operator`. [Pipes](https://www.geeksforgeeks.org/pipe-in-r/) are a bit more advanced than what we will be doing today, but their main benefit is to chain together multiple operations. 

You can just as easily generate the same table by using the `small_star_wars` Tibble variable as the argument passed to `gt()`:
```{r}
gt(small_star_wars)
```

With `gtExtras`, you can do some cool things with the pipe ` %>% ` to subset and group specific variables together quickly, and plot continuous variables right in your table (while applying some interesting visual styles): 

```{r}
#| layout: [[45,-1, 45], [100]]
#| code-fold: true
#| code-summary: "Show the code"

# These codes are more complex, but I'm including them here for extra credit in case anyone is curious to see how it's done (and how relatively easy it is).

small_star_wars %>%
  select(name, species, homeworld) %>% 
  # Here we select the subset of the total variables we want to include
  group_by(homeworld) %>% 
  # Group them together by one of those variables (here `homeworld`)
  gt() %>%
  gt_theme_pff() 
  # Plot, and then apply a theme

small_star_wars %>%
  select(name, species, homeworld) %>%
  group_by(species) %>%
  gt() %>%
  gt_theme_guardian()
  # Same as above, just grouping by `species`

agg_star_wars <- starwars %>%
  # This is a bit more complicated 
  # To show more interesting distributions, I'm using the whole `starwars` dataset to include more data points
  filter(species %in% c("Human", "Droid", "Gungan")) %>% 
  # I'm filtering to just a few species that have more than 2 entries
  select(species, height, mass, birth_year) %>% 
  # Selecting the variables we want to include and grouping by species
  group_by(species) %>%   
  # To make the plots, gtExtras requires your continuous variables to be in list form, so we do that using `summarize` and `list`
  summarize(
    Height = list(height),  
    Weight = list(mass),    
    Born = list(birth_year) 
    # This generates a list, by our grouping variable, of each observation's height, mass, and birth year
  ) # And wesave all this as an "aggregated" dataset named `agg_star_wars`

agg_star_wars %>%
  gt() %>%
  gt_plt_dist(        
    Height,
    type = "density" 
    # This is the code to generate the distribution plots, with arguments to tell it what type of plot we want
  ) %>%
  gt_plt_dist(
    Weight,
    type = "boxplot"
  ) %>%
  gt_plt_dist(
    Born,
    type = "rug_strip"
  ) %>% 
  gt_theme_nytimes()
```